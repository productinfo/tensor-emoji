<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <style>
      #container {
        max-width: 500px;
        position: relative;
      }
      #container > * {
        position: absolute;
        width: 100%;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <video id="webcam" autoplay="true" width="500" height="375"></video><canvas id="output"></canvas>
    </div>

    <script src="https://unpkg.com/@tensorflow/tfjs"></script>
    <script src="https://unpkg.com/@tensorflow-models/posenet"></script>

    <script>
      (async () => {
        const constraints = {
          audio: false,
          video: true
        };

        const loadVideo = async element => {
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          element.srcObject = stream;
          return new Promise(resolve => (element.onloadedmetadata = () => resolve(element)));
        };

        let video;
        try {
          video = await loadVideo(document.querySelector('#webcam'));
        } catch (err) {
          alert('Did you block the camera? Please unblock & refresh.');
          return;
        }

        const canvas = document.querySelector('#output');
        canvas.width = webcam.clientWidth;
        canvas.height = webcam.clientHeight;
        const ctx = canvas.getContext('2d');

        const threshold = 0.8;
        const emojiSize = 32;
        const emoji = ['ðŸ©', 'ðŸ¦…', 'ðŸ¦…'];
        const scale = 1;

        ctx.font = `${emojiSize}px sans-serif`;

        async function poseDetectionFrame() {
          const net = await posenet.load(0.75);
          const pose = await net.estimateSinglePose(video, 0.75, false, 16);

          const [nose, rightEye, leftEye] = pose.keypoints;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          [nose, leftEye, rightEye].forEach(({ score, position }, index) => {
            if (score > threshold) {
              const { y, x } = position;
              ctx.fillText(emoji[index], x * scale - emojiSize / 2, y * scale + emojiSize / 2);
            }
          });

          requestAnimationFrame(poseDetectionFrame);
        }

        poseDetectionFrame();
      })();
    </script>
  </body>
</html>
